// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.15/esri/copyright.txt for details.
//>>built
define("require exports ../../../../core/tsSupport/makeTemplateObjectHelper ../core/shaderLibrary/DiscardOrAdjustAlpha.glsl ../core/shaderLibrary/ForwardLinearDepth.glsl ../core/shaderLibrary/Offset.glsl ../core/shaderLibrary/Slice.glsl ../core/shaderLibrary/Transform.glsl ../core/shaderLibrary/attributes/InstancedDoublePrecision.glsl ../core/shaderLibrary/attributes/NormalAttribute.glsl ../core/shaderLibrary/attributes/PositionAttribute.glsl ../core/shaderLibrary/attributes/SymbolColor.glsl ../core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl ../core/shaderLibrary/attributes/VertexColor.glsl ../core/shaderLibrary/attributes/VertexNormal.glsl ../core/shaderLibrary/attributes/VerticalOffset.glsl ../core/shaderLibrary/default/DefaultMaterialAuxiliaryPasses.glsl ../core/shaderLibrary/shading/ComputeNormalTexture.glsl ../core/shaderLibrary/shading/EvaluateAmbientOcclusion.glsl ../core/shaderLibrary/shading/EvaluateSceneLighting.glsl ../core/shaderLibrary/shading/Normals.glsl ../core/shaderLibrary/shading/PhysicallyBasedRendering.glsl ../core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl ../core/shaderLibrary/shading/ReadShadowMap.glsl ../core/shaderLibrary/shading/VisualVariables.glsl ../core/shaderLibrary/util/MixExternalColor.glsl ../core/shaderModules/interfaces ../core/shaderModules/ShaderBuilder".split(" "),
function(U,e,c,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,d,S){Object.defineProperty(e,"__esModule",{value:!0});e.build=function(a){var b=new S.ShaderBuilder,e=b.vertex.code,T=b.fragment.code;b.vertex.uniforms.add("proj","mat4").add("view","mat4").add("camPos","vec3").add("localOrigin","vec3");b.include(C.PositionAttribute);b.varyings.add("vpos","vec3");b.include(Q.VisualVariables,a);b.include(A.InstancedDoublePrecision,a);b.include(H.VerticalOffset,a);0===a.output&&(b.include(B.NormalAttribute,
a),b.include(z.Transform,{linearDepth:!1}),0===a.normalType&&a.offsetBackfaces&&b.include(x.Offset),b.include(J.ComputeNormalTexture,a),b.include(G.VertexNormal,a),a.instancedColor&&b.attributes.add("instanceColor","vec4"),b.varyings.add("localvpos","vec3"),b.include(E.TextureCoordinateAttribute,a),b.include(w.ForwardLinearDepth,a),b.include(D.SymbolColor,a),b.include(F.VertexColor,a),b.vertex.uniforms.add("externalColor","vec4"),b.varyings.add("vcolorExt","vec4"),b.vertex.defines.addFloat("SYMBOL_ALPHA_CUTOFF",
.001),e.add(d.glsl(f||(f=c(["\n      void main(void) {\n        forwardNormalizedVertexColor();\n        vcolorExt \x3d externalColor;\n        ","\n        vcolorExt *\x3d vvColor();\n        vcolorExt *\x3d getSymbolColor();\n        forwardColorMixMode();\n\n        if (vcolorExt.a \x3c SYMBOL_ALPHA_CUTOFF) {\n          gl_Position \x3d vec4(1e38, 1e38, 1e38, 1.0);\n        }\n        else {\n          vpos \x3d calculateVPos();\n          localvpos \x3d vpos - view[3].xyz;\n          vpos \x3d subtractOrigin(vpos);\n          ",
"\n          vpos \x3d addVerticalOffset(vpos, localOrigin);\n          ","\n          gl_Position \x3d transformPosition(proj, view, vpos);\n          ","\n        }\n        forwardLinearDepth();\n        forwardTextureCoordinates();\n      }\n    "],["\n      void main(void) {\n        forwardNormalizedVertexColor();\n        vcolorExt \x3d externalColor;\n        ","\n        vcolorExt *\x3d vvColor();\n        vcolorExt *\x3d getSymbolColor();\n        forwardColorMixMode();\n\n        if (vcolorExt.a \x3c SYMBOL_ALPHA_CUTOFF) {\n          gl_Position \x3d vec4(1e38, 1e38, 1e38, 1.0);\n        }\n        else {\n          vpos \x3d calculateVPos();\n          localvpos \x3d vpos - view[3].xyz;\n          vpos \x3d subtractOrigin(vpos);\n          ",
"\n          vpos \x3d addVerticalOffset(vpos, localOrigin);\n          ","\n          gl_Position \x3d transformPosition(proj, view, vpos);\n          ","\n        }\n        forwardLinearDepth();\n        forwardTextureCoordinates();\n      }\n    "])),a.instancedColor?"vcolorExt *\x3d instanceColor;":"",0===a.normalType?d.glsl(g||(g=c(["\n          vNormalWorld \x3d dpNormal(vvLocalNormal(normalModel()));"],["\n          vNormalWorld \x3d dpNormal(vvLocalNormal(normalModel()));"]))):"",a.vertexTangets?
"transformVertexTangent(mat3(modelNormal));":"",0===a.normalType&&a.offsetBackfaces?"gl_Position \x3d offsetBackfacingClipPosition(gl_Position, vpos, vNormalWorld, camPos);":"")),b.include(y.Slice,a),b.include(L.EvaluateSceneLighting,a),b.include(K.EvaluateAmbientOcclusion,a),b.include(v.DiscardOrAdjustAlpha,a),a.receiveShadows&&b.include(P.ReadShadowMap,a),b.fragment.uniforms.add("camPos","vec3").add("localOrigin","vec3").add("ambient","vec3").add("diffuse","vec3").add("opacity","float").add("layerOpacity",
"float"),a.hasColorTexture&&b.fragment.uniforms.add("tex","sampler2D"),b.include(O.PhysicallyBasedRenderingParameters,a),b.include(N.PhysicallyBasedRendering,a),b.include(R.MixExternalColor,{stages:1}),b.include(M.Normals,a),T.add(d.glsl(h||(h=c(["\n      void main() {\n        discardBySlice(vpos);\n        ","\n        shadingParams.viewDirection \x3d normalize(vpos - camPos);\n        ","\n        ","\n        float ssao \x3d evaluateAmbientOcclusionInverse();\n        ssao *\x3d getBakedOcclusion();\n\n        float additionalAmbientScale \x3d _oldHeuristicLighting(vpos + localOrigin);\n        vec3 additionalLight \x3d ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n        ",
"\n        vec3 matColor \x3d max(ambient, diffuse);\n        ","\n        ","\n        ","\n        gl_FragColor \x3d highlightSlice(vec4(shadedColor, opacity_), vpos);\n      }\n    "],["\n      void main() {\n        discardBySlice(vpos);\n        ","\n        shadingParams.viewDirection \x3d normalize(vpos - camPos);\n        ","\n        ","\n        float ssao \x3d evaluateAmbientOcclusionInverse();\n        ssao *\x3d getBakedOcclusion();\n\n        float additionalAmbientScale \x3d _oldHeuristicLighting(vpos + localOrigin);\n        vec3 additionalLight \x3d ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n        ",
"\n        vec3 matColor \x3d max(ambient, diffuse);\n        ","\n        ","\n        ","\n        gl_FragColor \x3d highlightSlice(vec4(shadedColor, opacity_), vpos);\n      }\n    "])),a.hasColorTexture?d.glsl(k||(k=c(["\n        vec4 texColor \x3d texture2D(tex, vuv0);\n        ","\n        discardOrAdjustAlpha(texColor);"],["\n        vec4 texColor \x3d texture2D(tex, vuv0);\n        ","\n        discardOrAdjustAlpha(texColor);"])),a.textureAlphaPremultiplied?"texColor.rgb /\x3d texColor.a;":
""):d.glsl(l||(l=c(["vec4 texColor \x3d vec4(1.0);"],["vec4 texColor \x3d vec4(1.0);"]))),3===a.normalType?d.glsl(m||(m=c(["\n        vec3 normal \x3d screenDerivativeNormal(localvpos);"],["\n        vec3 normal \x3d screenDerivativeNormal(localvpos);"]))):d.glsl(n||(n=c(["\n        shadingParams.normalView \x3d vNormalWorld;\n        vec3 normal \x3d shadingNormal(shadingParams);"],["\n        shadingParams.normalView \x3d vNormalWorld;\n        vec3 normal \x3d shadingNormal(shadingParams);"]))),
a.usePBR?"applyPBRFactors();":"",a.receiveShadows?"float shadow \x3d readShadowMap(vpos, linearDepth);":0===a.viewingMode?"float shadow \x3d lightingGlobalFactor * (1.0 - additionalAmbientScale);":"float shadow \x3d 0.0;",a.attributeColor?d.glsl(p||(p=c(["\n        vec3 albedo_ \x3d mixExternalColor(vColor.rgb * matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n        float opacity_ \x3d layerOpacity * mixExternalOpacity(vColor.a * opacity, texColor.a, vcolorExt.a, int(colorMixMode));"],
["\n        vec3 albedo_ \x3d mixExternalColor(vColor.rgb * matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n        float opacity_ \x3d layerOpacity * mixExternalOpacity(vColor.a * opacity, texColor.a, vcolorExt.a, int(colorMixMode));"]))):d.glsl(q||(q=c(["\n        vec3 albedo_ \x3d mixExternalColor(matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n        float opacity_ \x3d layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, int(colorMixMode));\n          ",
""],["\n        vec3 albedo_ \x3d mixExternalColor(matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n        float opacity_ \x3d layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, int(colorMixMode));\n          ",""])),a.usePBR?d.glsl(r||(r=c(["\n          if (int(colorMixMode) \x3d\x3d 3) {\n            reflectance \x3d 0.2;\n            roughness \x3d 0.6;\n            metalness \x3d 0.0;\n          }"],["\n          if (int(colorMixMode) \x3d\x3d 3) {\n            reflectance \x3d 0.2;\n            roughness \x3d 0.6;\n            metalness \x3d 0.0;\n          }"]))):
""),a.hasNormalTexture?d.glsl(t||(t=c(["\n              mat3 tangentSpace \x3d ","\n              vec3 shadedNormal \x3d computeTextureNormal(tangentSpace, vuv0);"],["\n              mat3 tangentSpace \x3d ","\n              vec3 shadedNormal \x3d computeTextureNormal(tangentSpace, vuv0);"])),a.vertexTangets?"computeTangentSpace(normal);":"computeTangentSpace(normal, vpos, vuv0);"):"vec3 shadedNormal \x3d normal;",a.usePBR?d.glsl(u||(u=c(["\n            float additionalAmbientIrradiance \x3d additionalAmbientIrradianceFactor * lightingMainIntensity[2];\n            vec3 normalGround \x3d normalize(vpos + localOrigin);\n            vec3 shadedColor \x3d evaluateSceneLightingPBR(shadedNormal, albedo_, shadow, 1.0 - ssao, additionalLight, shadingParams.viewDirection, normalGround, roughness, metalness, emission, reflectance, additionalAmbientIrradiance);"],
["\n            float additionalAmbientIrradiance \x3d additionalAmbientIrradianceFactor * lightingMainIntensity[2];\n            vec3 normalGround \x3d normalize(vpos + localOrigin);\n            vec3 shadedColor \x3d evaluateSceneLightingPBR(shadedNormal, albedo_, shadow, 1.0 - ssao, additionalLight, shadingParams.viewDirection, normalGround, roughness, metalness, emission, reflectance, additionalAmbientIrradiance);"]))):"vec3 shadedColor \x3d evaluateSceneLighting(shadedNormal, albedo_, shadow, 1.0 - ssao, additionalLight);")));
b.include(I.DefaultMaterialAuxiliaryPasses,a);return b};var g,f,k,l,m,n,p,r,q,t,u,h});