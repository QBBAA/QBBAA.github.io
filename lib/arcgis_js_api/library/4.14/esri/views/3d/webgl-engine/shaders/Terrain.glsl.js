// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.15/esri/copyright.txt for details.
//>>built
define("require exports ../../../../core/tsSupport/makeTemplateObjectHelper ../core/shaderLibrary/Slice.glsl ../core/shaderLibrary/Transform.glsl ../core/shaderLibrary/output/OutputDepth.glsl ../core/shaderLibrary/output/OutputHighlight.glsl ../core/shaderLibrary/shading/EvaluateSceneLighting.glsl ../core/shaderLibrary/shading/NormalUtils.glsl ../core/shaderLibrary/util/RgbaFloatEncoding.glsl ../core/shaderModules/interfaces ../core/shaderModules/ShaderBuilder ./Overlay.glsl ./Skirts.glsl".split(" "),
function(ca,g,c,V,e,W,X,Y,f,Z,d,aa,h,ba){Object.defineProperty(g,"__esModule",{value:!0});g.build=function(b){var a=new aa.ShaderBuilder;a.include(ba.Skirts);a.attributes.add("position","vec3");a.attributes.add("uv0","vec2");a.vertex.uniforms.add("proj","mat4").add("view","mat4").add("origin","vec3").add("skirtScale","float");0===b.output&&(a.include(e.Transform,{linearDepth:!1}),a.include(f.NormalUtils,b),b.overlayEnabled&&a.include(h.Overlay,{usePBR:!1,usePBRforWater:!0,useCustomDTRExponentForWater:!1}),
a.varyings.add("vnormal","vec3"),a.varyings.add("vpos","vec3"),a.varyings.add("vtc","vec2"),a.vertex.uniforms.add("viewNormal","mat4"),a.vertex.uniforms.add("texOffsetAndScale","vec4"),a.vertex.uniforms.add("oldTexOffsetAndScale","vec4"),b.receiveShadows&&a.varyings.add("linearDepth","float"),b.tileBorders&&a.varyings.add("vuv","vec2"),b.atmosphere&&(a.vertex.uniforms.add("lightingMainDirection","vec3"),a.varyings.add("wnormal","vec3"),a.varyings.add("wlight","vec3")),b.overlayEnabled&&(a.varyings.add("tbnTangent",
"vec3"),a.varyings.add("tbnBiTangent","vec3")),b.blendingEnabled&&a.varyings.add("ovtc","vec2"),b.screenSizePerspective&&(a.vertex.uniforms.add("screenSizePerspective","vec4"),a.varyings.add("screenSizeDistanceToCamera","float"),a.varyings.add("screenSizeCosAngle","float")),a.vertex.code.add(d.glsl(k||(k=c(["\n      void main(void) {\n        vpos \x3d position;\n        vnormal \x3d getLocalUp(vpos, origin);\n\n        vec2 uv \x3d uv0;\n        vpos \x3d applySkirts(uv, vpos, vnormal, skirtScale);\n      "],
["\n      void main(void) {\n        vpos \x3d position;\n        vnormal \x3d getLocalUp(vpos, origin);\n\n        vec2 uv \x3d uv0;\n        vpos \x3d applySkirts(uv, vpos, vnormal, skirtScale);\n      "])))),b.atmosphere&&a.vertex.code.add(d.glsl(l||(l=c(["\n        wnormal \x3d (viewNormal * vec4(normalize(vpos+origin), 1.0)).xyz;\n        wlight \x3d (view  * vec4(-lightingMainDirection, 1.0)).xyz;\n      "],["\n        wnormal \x3d (viewNormal * vec4(normalize(vpos+origin), 1.0)).xyz;\n        wlight \x3d (view  * vec4(-lightingMainDirection, 1.0)).xyz;\n      "])))),
b.tileBorders&&a.vertex.code.add(d.glsl(m||(m=c(["\n        vuv \x3d uv;\n      "],["\n        vuv \x3d uv;\n      "])))),b.screenSizePerspective&&a.vertex.code.add(d.glsl(n||(n=c(["\n        vec3 viewPos \x3d (view * vec4(vpos, 1.0)).xyz;\n        screenSizeDistanceToCamera \x3d length(viewPos);\n        vec3 viewSpaceNormal \x3d (viewNormal * vec4(normalize(vpos + origin), 1.0)).xyz;\n        screenSizeCosAngle \x3d abs(viewSpaceNormal.z);\n      "],["\n        vec3 viewPos \x3d (view * vec4(vpos, 1.0)).xyz;\n        screenSizeDistanceToCamera \x3d length(viewPos);\n        vec3 viewSpaceNormal \x3d (viewNormal * vec4(normalize(vpos + origin), 1.0)).xyz;\n        screenSizeCosAngle \x3d abs(viewSpaceNormal.z);\n      "])))),
a.vertex.code.add(d.glsl(p||(p=c(["\n        gl_Position \x3d transformPosition(proj, view, vpos);\n      "],["\n        gl_Position \x3d transformPosition(proj, view, vpos);\n      "])))),b.receiveShadows&&a.vertex.code.add(d.glsl(q||(q=c(["\n        linearDepth \x3d gl_Position.w;\n      "],["\n        linearDepth \x3d gl_Position.w;\n      "])))),a.vertex.code.add(d.glsl(r||(r=c(["\n        vtc \x3d uv * texOffsetAndScale.zw + texOffsetAndScale.xy;\n      "],["\n        vtc \x3d uv * texOffsetAndScale.zw + texOffsetAndScale.xy;\n      "])))),
b.overlayEnabled&&(a.vertex.code.add(d.glsl(t||(t=c(["\n        setOverlayVTC(uv);\n      "],["\n        setOverlayVTC(uv);\n      "])))),0===b.viewingMode?a.vertex.code.add(d.glsl(u||(u=c(["\n          tbnTangent \x3d normalize(cross(vec3(0.0, 0.0, 1.0), vnormal));\n          tbnBiTangent \x3d normalize(cross(vnormal, tbnTangent));\n          "],["\n          tbnTangent \x3d normalize(cross(vec3(0.0, 0.0, 1.0), vnormal));\n          tbnBiTangent \x3d normalize(cross(vnormal, tbnTangent));\n          "])))):
a.vertex.code.add(d.glsl(v||(v=c(["\n          tbnTangent \x3d vec3(1.0, 0.0, 0.0);\n          tbnBiTangent \x3d normalize(cross(vnormal, tbnTangent));\n        "],["\n          tbnTangent \x3d vec3(1.0, 0.0, 0.0);\n          tbnBiTangent \x3d normalize(cross(vnormal, tbnTangent));\n        "]))))),b.blendingEnabled&&a.vertex.code.add(d.glsl(w||(w=c(["\n        ovtc \x3d uv * oldTexOffsetAndScale.zw + oldTexOffsetAndScale.xy;\n    "],["\n        ovtc \x3d uv * oldTexOffsetAndScale.zw + oldTexOffsetAndScale.xy;\n    "])))),
a.vertex.code.add(d.glsl(x||(x=c(["\n      }\n    "],["\n      }\n    "])))),a.extensions.add("GL_OES_standard_derivatives"),a.extensions.add("GL_EXT_shader_texture_lod"),a.include(V.Slice,b),a.include(Y.EvaluateSceneLighting,b),a.fragment.uniforms.add("camPos","vec3").add("viewDirection","vec3").add("ssaoTex","sampler2D").add("viewportPixelSz","vec4").add("tex","sampler2D").add("opacity","float"),b.screenSizePerspective&&a.fragment.uniforms.add("screenSizePerspective","vec4"),a.fragment.code.add(d.glsl(y||
(y=c(["\n      const vec3 ambient \x3d vec3(0.2, 0.2, 0.2);\n      const vec3 diffuse \x3d vec3(0.8, 0.8, 0.8);\n      const float diffuseHardness \x3d 2.5;\n      const float sliceOpacity \x3d 0.2;\n    "],["\n      const vec3 ambient \x3d vec3(0.2, 0.2, 0.2);\n      const vec3 diffuse \x3d vec3(0.8, 0.8, 0.8);\n      const float diffuseHardness \x3d 2.5;\n      const float sliceOpacity \x3d 0.2;\n    "])))),b.overlayEnabled&&(a.fragment.uniforms.add("ovInnerWaterTex","sampler2D"),a.fragment.uniforms.add("ovOuterWaterTex",
"sampler2D")),b.blendingEnabled&&a.fragment.uniforms.add("texOld","sampler2D").add("blend","float"),a.fragment.code.add(d.glsl(z||(z=c(["\n      float lum(vec3 c) {\n        float max \x3d max(max(c.r, c.g), c.b);\n        float min \x3d min(min(c.r, c.g), c.b);\n        return (min + max) * 0.5;\n      }\n      "],["\n      float lum(vec3 c) {\n        float max \x3d max(max(c.r, c.g), c.b);\n        float min \x3d min(min(c.r, c.g), c.b);\n        return (min + max) * 0.5;\n      }\n      "])))),
b.atmosphere&&a.fragment.code.add(d.glsl(A||(A=c(["\n      vec3 atmosphere(vec3 lightPos, vec3 normal, vec3 view) {\n        vec3 surfaceColor   \x3d vec3(0.0);\n        vec3 fuzzySpecColor \x3d vec3(1.0);\n        vec3 subColor       \x3d vec3(0.0);\n        float rollOff       \x3d 1.0;\n\n        vec3 Ln \x3d normalize(lightPos);\n        vec3 Nn \x3d normalize(normal);\n        vec3 Hn \x3d normalize(view + Ln);\n\n        float ldn \x3d dot(Ln, Nn);\n        float diffComp \x3d max(0.0, ldn);\n        // clamp necessary here because values might cause flickering: #21549\n        float vdn \x3d clamp(1.0 - dot(view, Nn), 0.0, 1.0);\n        float ndv \x3d dot(view, Ln);\n\n        vec3 diffContrib \x3d surfaceColor * diffComp;\n        float subLamb \x3d max(0.0, smoothstep(-rollOff, 1.0, ldn) - smoothstep(0.0, 1.0, ldn));\n\n        vec3 subContrib \x3d subLamb * subColor;\n        vec3 vecColor \x3d vec3(vdn);\n\n        vec3 diffuseContrib \x3d (subContrib + diffContrib);\n        vec3 specularContrib \x3d (vecColor * fuzzySpecColor);\n\n        return (diffContrib + specularContrib) * rollOff;\n      }\n      "],
["\n      vec3 atmosphere(vec3 lightPos, vec3 normal, vec3 view) {\n        vec3 surfaceColor   \x3d vec3(0.0);\n        vec3 fuzzySpecColor \x3d vec3(1.0);\n        vec3 subColor       \x3d vec3(0.0);\n        float rollOff       \x3d 1.0;\n\n        vec3 Ln \x3d normalize(lightPos);\n        vec3 Nn \x3d normalize(normal);\n        vec3 Hn \x3d normalize(view + Ln);\n\n        float ldn \x3d dot(Ln, Nn);\n        float diffComp \x3d max(0.0, ldn);\n        // clamp necessary here because values might cause flickering: #21549\n        float vdn \x3d clamp(1.0 - dot(view, Nn), 0.0, 1.0);\n        float ndv \x3d dot(view, Ln);\n\n        vec3 diffContrib \x3d surfaceColor * diffComp;\n        float subLamb \x3d max(0.0, smoothstep(-rollOff, 1.0, ldn) - smoothstep(0.0, 1.0, ldn));\n\n        vec3 subContrib \x3d subLamb * subColor;\n        vec3 vecColor \x3d vec3(vdn);\n\n        vec3 diffuseContrib \x3d (subContrib + diffContrib);\n        vec3 specularContrib \x3d (vecColor * fuzzySpecColor);\n\n        return (diffContrib + specularContrib) * rollOff;\n      }\n      "])))),
a.fragment.code.add(d.glsl(B||(B=c(["\n      void main() {\n      "],["\n      void main() {\n      "])))),b.receiveShadows?a.fragment.code.add(d.glsl(C||(C=c(["\n        float shadow \x3d readShadowMap(vpos, linearDepth);\n      "],["\n        float shadow \x3d readShadowMap(vpos, linearDepth);\n      "])))):a.fragment.code.add(d.glsl(D||(D=c(["\n        float shadow \x3d 0.0;\n      "],["\n        float shadow \x3d 0.0;\n      "])))),a.fragment.code.add(d.glsl(E||(E=c(["\n        float vndl \x3d dot(normalize(vnormal), -lightingMainDirection);\n        float k \x3d smoothstep(0.0, 1.0, clamp(vndl*diffuseHardness, 0.0, 1.0));\n        vec3 d \x3d (1.0 - shadow/1.8) * diffuse * k;\n\n        float ssao \x3d viewportPixelSz.w \x3c .0 ? 1.0 : texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;\n      "],
["\n        float vndl \x3d dot(normalize(vnormal), -lightingMainDirection);\n        float k \x3d smoothstep(0.0, 1.0, clamp(vndl*diffuseHardness, 0.0, 1.0));\n        vec3 d \x3d (1.0 - shadow/1.8) * diffuse * k;\n\n        float ssao \x3d viewportPixelSz.w \x3c .0 ? 1.0 : texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;\n      "])))),b.blendingEnabled?a.fragment.code.add(d.glsl(F||(F=c(["\n        vec4 tileColor \x3d (blend \x3c 1.0 ? mix(texture2D(texOld, ovtc), texture2D(tex, vtc), blend) : texture2D(tex, vtc)) * opacity;\n      "],
["\n        vec4 tileColor \x3d (blend \x3c 1.0 ? mix(texture2D(texOld, ovtc), texture2D(tex, vtc), blend) : texture2D(tex, vtc)) * opacity;\n      "])))):a.fragment.code.add(d.glsl(G||(G=c(["\n        vec4 tileColor \x3d texture2D(tex, vtc) * opacity;\n      "],["\n        vec4 tileColor \x3d texture2D(tex, vtc) * opacity;\n      "])))),b.overlayEnabled&&a.fragment.code.add(d.glsl(H||(H=c(["\n        vec4 overlayColor \x3d getCombinedOverlayColor();\n        tileColor \x3d tileColor * (1.0 - overlayColor.a) + overlayColor;\n      "],
["\n        vec4 overlayColor \x3d getCombinedOverlayColor();\n        tileColor \x3d tileColor * (1.0 - overlayColor.a) + overlayColor;\n      "])))),a.fragment.code.add(d.glsl(I||(I=c(["\n        if (rejectBySlice(vpos)) {\n          tileColor *\x3d sliceOpacity;\n        }\n        vec3 atm \x3d vec3(0.0);\n      "],["\n        if (rejectBySlice(vpos)) {\n          tileColor *\x3d sliceOpacity;\n        }\n        vec3 atm \x3d vec3(0.0);\n      "])))),b.atmosphere&&a.fragment.code.add(d.glsl(J||
(J=c(["\n        float ndotl \x3d max(0.0, min(1.0, vndl));\n        atm \x3d atmosphere(wlight, wnormal, -viewDirection);\n        atm *\x3d max(0.0, min(1.0, (1.0-lum(tileColor.rgb)*1.5))); //avoid atmosphere on bright base maps\n        atm *\x3d max(0.0, min(1.0, ndotl*2.0)); // avoid atmosphere on dark side of the globe\n        atm *\x3d tileColor.a; // premultiply with tile alpha\n      "],["\n        float ndotl \x3d max(0.0, min(1.0, vndl));\n        atm \x3d atmosphere(wlight, wnormal, -viewDirection);\n        atm *\x3d max(0.0, min(1.0, (1.0-lum(tileColor.rgb)*1.5))); //avoid atmosphere on bright base maps\n        atm *\x3d max(0.0, min(1.0, ndotl*2.0)); // avoid atmosphere on dark side of the globe\n        atm *\x3d tileColor.a; // premultiply with tile alpha\n      "])))),
a.fragment.code.add(d.glsl(K||(K=c(["\n        vec3 albedo \x3d atm + tileColor.rgb;\n        vec3 normal \x3d normalize(vnormal);\n\n        // heuristic shading function used in the old terrain, now used to add ambient lighting\n        float additionalAmbientScale \x3d smoothstep(0.0, 1.0, clamp(vndl*2.5, 0.0, 1.0));\n        vec3 additionalLight \x3d ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n\n        gl_FragColor \x3d vec4(evaluateSceneLightingExt(normal, albedo, shadow, 1.0 - ssao, additionalLight), tileColor.a);\n      "],
["\n        vec3 albedo \x3d atm + tileColor.rgb;\n        vec3 normal \x3d normalize(vnormal);\n\n        // heuristic shading function used in the old terrain, now used to add ambient lighting\n        float additionalAmbientScale \x3d smoothstep(0.0, 1.0, clamp(vndl*2.5, 0.0, 1.0));\n        vec3 additionalLight \x3d ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n\n        gl_FragColor \x3d vec4(evaluateSceneLightingExt(normal, albedo, shadow, 1.0 - ssao, additionalLight), tileColor.a);\n      "])))),
b.overlayEnabled&&a.fragment.code.add(d.glsl(L||(L=c(["\n        vec4 overlayWaterMask \x3d getOverlayColor(ovInnerWaterTex, ovOuterWaterTex, vtcOverlay);\n\n        float waterNormalLength \x3d length(overlayWaterMask);\n        if (waterNormalLength \x3e 0.95) {\n          mat3 tbnMatrix \x3d mat3(tbnTangent, tbnBiTangent, vnormal);\n          vec4 waterColor \x3d overlayOpacity * getOverlayWaterColor(tileColor, overlayWaterMask, overlayColor, vpos, shadow, vnormal, camPos, tbnMatrix);\n          // un-gamma the ground color to mix in linear space\n          vec4 groundColor \x3d vec4(pow(gl_FragColor.rgb, vec3(2.2)), gl_FragColor.w);\n          waterColor \x3d mix(groundColor, waterColor, waterColor.a);\n          gl_FragColor \x3d delinearizeGamma(waterColor);\n        }\n      "],
["\n        vec4 overlayWaterMask \x3d getOverlayColor(ovInnerWaterTex, ovOuterWaterTex, vtcOverlay);\n\n        float waterNormalLength \x3d length(overlayWaterMask);\n        if (waterNormalLength \x3e 0.95) {\n          mat3 tbnMatrix \x3d mat3(tbnTangent, tbnBiTangent, vnormal);\n          vec4 waterColor \x3d overlayOpacity * getOverlayWaterColor(tileColor, overlayWaterMask, overlayColor, vpos, shadow, vnormal, camPos, tbnMatrix);\n          // un-gamma the ground color to mix in linear space\n          vec4 groundColor \x3d vec4(pow(gl_FragColor.rgb, vec3(2.2)), gl_FragColor.w);\n          waterColor \x3d mix(groundColor, waterColor, waterColor.a);\n          gl_FragColor \x3d delinearizeGamma(waterColor);\n        }\n      "])))),
b.screenSizePerspective&&a.fragment.code.add(d.glsl(M||(M=c(["\n        float perspectiveScale \x3d screenSizePerspectiveScaleFloat(1.0, screenSizeCosAngle, screenSizeDistanceToCamera, screenSizePerspective);\n        if (perspectiveScale \x3c\x3d 0.25) {\n          gl_FragColor \x3d mix(gl_FragColor, vec4(1.0, 0.0, 0.0, 1.0), perspectiveScale * 4.0);\n        }\n        else if (perspectiveScale \x3c\x3d 0.5) {\n          gl_FragColor \x3d mix(gl_FragColor, vec4(0.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.25) * 4.0);\n        }\n        else if (perspectiveScale \x3e\x3d 0.99) {\n          gl_FragColor \x3d mix(gl_FragColor, vec4(0.0, 1.0, 0.0, 1.0), 0.2);\n        }\n        else {\n          gl_FragColor \x3d mix(gl_FragColor, vec4(1.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.5) * 2.0);\n        }\n      "],
["\n        float perspectiveScale \x3d screenSizePerspectiveScaleFloat(1.0, screenSizeCosAngle, screenSizeDistanceToCamera, screenSizePerspective);\n        if (perspectiveScale \x3c\x3d 0.25) {\n          gl_FragColor \x3d mix(gl_FragColor, vec4(1.0, 0.0, 0.0, 1.0), perspectiveScale * 4.0);\n        }\n        else if (perspectiveScale \x3c\x3d 0.5) {\n          gl_FragColor \x3d mix(gl_FragColor, vec4(0.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.25) * 4.0);\n        }\n        else if (perspectiveScale \x3e\x3d 0.99) {\n          gl_FragColor \x3d mix(gl_FragColor, vec4(0.0, 1.0, 0.0, 1.0), 0.2);\n        }\n        else {\n          gl_FragColor \x3d mix(gl_FragColor, vec4(1.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.5) * 2.0);\n        }\n      "])))),
b.tileBorders&&a.fragment.code.add(d.glsl(N||(N=c(["\n        vec2 dVuv \x3d fwidth(vuv);\n        vec2 edgeFactors \x3d smoothstep(vec2(0.0), 1.5 * dVuv, min(vuv, 1.0 - vuv));\n        float edgeFactor \x3d 1.0 - min(edgeFactors.x, edgeFactors.y);\n\n        gl_FragColor \x3d mix(gl_FragColor, vec4(1.0, 0.0, 0.0, 1.0), edgeFactor);\n      "],["\n        vec2 dVuv \x3d fwidth(vuv);\n        vec2 edgeFactors \x3d smoothstep(vec2(0.0), 1.5 * dVuv, min(vuv, 1.0 - vuv));\n        float edgeFactor \x3d 1.0 - min(edgeFactors.x, edgeFactors.y);\n\n        gl_FragColor \x3d mix(gl_FragColor, vec4(1.0, 0.0, 0.0, 1.0), edgeFactor);\n      "])))),
a.fragment.code.add(d.glsl(O||(O=c(["\n        gl_FragColor \x3d highlightSlice(gl_FragColor, vpos);\n      }\n    "],["\n        gl_FragColor \x3d highlightSlice(gl_FragColor, vpos);\n      }\n    "])))));if(1===b.output||3===b.output)a.include(e.Transform,{linearDepth:!0}),a.include(Z.RgbaFloatEncoding),a.include(W.OutputDepth,{output:b.output}),a.include(f.NormalUtils,b),a.varyings.add("linearDepth","float"),a.vertex.uniforms.add("nearFar","vec2"),a.vertex.code.add(d.glsl(P||(P=c(["\n        void main(void) {\n          vec3 normal \x3d getLocalUp(position, origin);\n          vec2 uv \x3d uv0;\n          vec3 vpos \x3d applySkirts(uv, position, normal.xyz, skirtScale);\n\n          gl_Position \x3d transformPositionWithDepth(proj, view, vpos, nearFar, linearDepth);\n        }\n    "],
["\n        void main(void) {\n          vec3 normal \x3d getLocalUp(position, origin);\n          vec2 uv \x3d uv0;\n          vec3 vpos \x3d applySkirts(uv, position, normal.xyz, skirtScale);\n\n          gl_Position \x3d transformPositionWithDepth(proj, view, vpos, nearFar, linearDepth);\n        }\n    "])))),a.fragment.code.add(d.glsl(Q||(Q=c(["\n        void main() {\n          outputDepth(linearDepth);\n        }\n    "],["\n        void main() {\n          outputDepth(linearDepth);\n        }\n    "]))));
2===b.output&&(a.include(e.Transform,{linearDepth:!1}),a.include(f.NormalUtils,b),a.varyings.add("vnormal","vec3"),a.varyings.add("vpos","vec3"),a.vertex.uniforms.add("viewNormal","mat4"),a.vertex.code.add(d.glsl(R||(R=c(["\n        void main(void) {\n          vec3 normal \x3d getLocalUp(position, origin);\n          vec2 uv \x3d uv0;\n          vpos \x3d applySkirts(uv, position, normal, skirtScale);\n\n          gl_Position \x3d transformPosition(proj, view, vpos);\n          vnormal \x3d normalize((viewNormal * vec4(normal, 1.0)).xyz);\n        }\n    "],
["\n        void main(void) {\n          vec3 normal \x3d getLocalUp(position, origin);\n          vec2 uv \x3d uv0;\n          vpos \x3d applySkirts(uv, position, normal, skirtScale);\n\n          gl_Position \x3d transformPosition(proj, view, vpos);\n          vnormal \x3d normalize((viewNormal * vec4(normal, 1.0)).xyz);\n        }\n    "])))),a.fragment.code.add(d.glsl(S||(S=c(["\n        void main() {\n          vec3 normal \x3d normalize(vnormal);\n          if (gl_FrontFacing \x3d\x3d false) {\n            normal \x3d -normal;\n          }\n          gl_FragColor \x3d vec4(vec3(0.5) + 0.5 * normal, 0.0);\n        }\n    "],
["\n        void main() {\n          vec3 normal \x3d normalize(vnormal);\n          if (gl_FrontFacing \x3d\x3d false) {\n            normal \x3d -normal;\n          }\n          gl_FragColor \x3d vec4(vec3(0.5) + 0.5 * normal, 0.0);\n        }\n    "])))));4===b.output&&(a.include(e.Transform,{linearDepth:!1}),a.include(f.NormalUtils,b),a.include(h.Overlay,{usePBR:!1,usePBRforWater:!1}),a.vertex.code.add(d.glsl(T||(T=c(["\n          void main() {\n            vec3 vnormal \x3d getLocalUp(position, origin);\n            vec2 uv \x3d uv0;\n            vec3 vpos \x3d applySkirts(uv, position, vnormal, skirtScale);\n            setOverlayVTC(uv);\n\n            gl_Position \x3d transformPosition(proj, view, vpos);\n          }\n      "],
["\n          void main() {\n            vec3 vnormal \x3d getLocalUp(position, origin);\n            vec2 uv \x3d uv0;\n            vec3 vpos \x3d applySkirts(uv, position, vnormal, skirtScale);\n            setOverlayVTC(uv);\n\n            gl_Position \x3d transformPosition(proj, view, vpos);\n          }\n      "])))),a.include(X.OutputHighlight),a.fragment.code.add(d.glsl(U||(U=c(["\n        void main() {\n          vec4 overlayColor \x3d getCombinedOverlayColor();\n\n          if (overlayColor.a \x3d\x3d 0.0) {\n            // Here we have to write black, instead of discarding the fragment in order to overwrite\n            // the highlights which might have been written by skirts of other tiles.\n            // As a consequence skirts are not visible, but terrain overwrites draped highlights.\n            gl_FragColor \x3d vec4(0.0);\n            return;\n          }\n\n          outputHighlight();\n        }\n      "],
["\n        void main() {\n          vec4 overlayColor \x3d getCombinedOverlayColor();\n\n          if (overlayColor.a \x3d\x3d 0.0) {\n            // Here we have to write black, instead of discarding the fragment in order to overwrite\n            // the highlights which might have been written by skirts of other tiles.\n            // As a consequence skirts are not visible, but terrain overwrites draped highlights.\n            gl_FragColor \x3d vec4(0.0);\n            return;\n          }\n\n          outputHighlight();\n        }\n      "])))));
return a};var k,l,m,n,p,q,r,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U});