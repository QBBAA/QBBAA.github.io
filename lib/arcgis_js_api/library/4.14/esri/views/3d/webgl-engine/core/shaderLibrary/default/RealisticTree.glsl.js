// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.15/esri/copyright.txt for details.
//>>built
define("require exports ../../../../../../core/tsSupport/makeTemplateObjectHelper ../DiscardOrAdjustAlpha.glsl ../ForwardLinearDepth.glsl ../Offset.glsl ../Slice.glsl ../Transform.glsl ../attributes/InstancedDoublePrecision.glsl ../attributes/NormalAttribute.glsl ../attributes/PositionAttribute.glsl ../attributes/SymbolColor.glsl ../attributes/TextureCoordinateAttribute.glsl ../attributes/VertexColor.glsl ../attributes/VerticalOffset.glsl ./DefaultMaterialAuxiliaryPasses.glsl ../shading/EvaluateAmbientOcclusion.glsl ../shading/EvaluateSceneLighting.glsl ../shading/PhysicallyBasedRendering.glsl ../shading/PhysicallyBasedRenderingParameters.glsl ../shading/ReadShadowMap.glsl ../shading/VisualVariables.glsl ../util/MixExternalColor.glsl ../../shaderModules/interfaces ../../shaderModules/ShaderBuilder".split(" "),
function(O,e,c,r,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,d,M){Object.defineProperty(e,"__esModule",{value:!0});e.build=function(b){var a=new M.ShaderBuilder,e=a.vertex.code,N=a.fragment.code;a.vertex.uniforms.add("proj","mat4").add("view","mat4").add("camPos","vec3").add("localOrigin","vec3");a.include(z.PositionAttribute);a.varyings.add("vpos","vec3");a.include(K.VisualVariables,b);a.include(x.InstancedDoublePrecision,b);a.include(D.VerticalOffset,b);0===b.output&&(a.include(y.NormalAttribute,b),a.include(w.Transform,
{linearDepth:!1}),b.offsetBackfaces&&a.include(u.Offset),b.instancedColor&&a.attributes.add("instanceColor","vec4"),a.varyings.add("vNormalWorld","vec3"),a.varyings.add("localvpos","vec3"),a.include(B.TextureCoordinateAttribute,b),a.include(t.ForwardLinearDepth,b),a.include(A.SymbolColor,b),a.include(C.VertexColor,b),a.vertex.uniforms.add("externalColor","vec4"),a.varyings.add("vcolorExt","vec4"),a.vertex.defines.addFloat("SYMBOL_ALPHA_CUTOFF",.001),e.add(d.glsl(f||(f=c(["\n        void main(void) {\n          forwardNormalizedVertexColor();\n          vcolorExt \x3d externalColor;\n          ",
"\n          vcolorExt *\x3d vvColor();\n          vcolorExt *\x3d getSymbolColor();\n          forwardColorMixMode();\n\n          if (vcolorExt.a \x3c SYMBOL_ALPHA_CUTOFF) {\n            gl_Position \x3d vec4(1e38, 1e38, 1e38, 1.0);\n          }\n          else {\n            vpos \x3d calculateVPos();\n            localvpos \x3d vpos - view[3].xyz;\n            vpos \x3d subtractOrigin(vpos);\n            vNormalWorld \x3d dpNormal(vvLocalNormal(normalModel()));\n            vpos \x3d addVerticalOffset(vpos, localOrigin);\n            gl_Position \x3d transformPosition(proj, view, vpos);\n            ",
"\n          }\n          forwardLinearDepth();\n          forwardTextureCoordinates();\n        }\n      "],["\n        void main(void) {\n          forwardNormalizedVertexColor();\n          vcolorExt \x3d externalColor;\n          ","\n          vcolorExt *\x3d vvColor();\n          vcolorExt *\x3d getSymbolColor();\n          forwardColorMixMode();\n\n          if (vcolorExt.a \x3c SYMBOL_ALPHA_CUTOFF) {\n            gl_Position \x3d vec4(1e38, 1e38, 1e38, 1.0);\n          }\n          else {\n            vpos \x3d calculateVPos();\n            localvpos \x3d vpos - view[3].xyz;\n            vpos \x3d subtractOrigin(vpos);\n            vNormalWorld \x3d dpNormal(vvLocalNormal(normalModel()));\n            vpos \x3d addVerticalOffset(vpos, localOrigin);\n            gl_Position \x3d transformPosition(proj, view, vpos);\n            ",
"\n          }\n          forwardLinearDepth();\n          forwardTextureCoordinates();\n        }\n      "])),b.instancedColor?"vcolorExt *\x3d instanceColor;":"",b.offsetBackfaces?"gl_Position \x3d offsetBackfacingClipPosition(gl_Position, vpos, vNormalWorld, camPos);":"")),a.include(v.Slice,b),a.include(G.EvaluateSceneLighting,b),a.include(F.EvaluateAmbientOcclusion,b),a.include(r.DiscardOrAdjustAlpha,b),b.receiveShadows&&a.include(J.ReadShadowMap,b),a.fragment.uniforms.add("camPos","vec3").add("localOrigin",
"vec3").add("ambient","vec3").add("diffuse","vec3").add("opacity","float").add("layerOpacity","float"),a.fragment.uniforms.add("view","mat4"),b.hasColorTexture&&a.fragment.uniforms.add("tex","sampler2D"),a.include(I.PhysicallyBasedRenderingParameters,b),a.include(H.PhysicallyBasedRendering,b),a.include(L.MixExternalColor,{stages:1}),N.add(d.glsl(g||(g=c(["\n      void main() {\n        discardBySlice(vpos);\n        ","\n        vec3 viewDirection \x3d normalize(vpos - camPos);\n        ","\n        float ssao \x3d evaluateAmbientOcclusionInverse();\n        ssao *\x3d getBakedOcclusion();\n\n        float additionalAmbientScale \x3d _oldHeuristicLighting(vpos + localOrigin);\n        vec3 additionalLight \x3d ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n        ",
"\n        vec3 matColor \x3d max(ambient, diffuse);\n        ","\n        ","\n        ","\n        gl_FragColor \x3d highlightSlice(vec4(shadedColor, opacity_), vpos);\n      }\n    "],["\n      void main() {\n        discardBySlice(vpos);\n        ","\n        vec3 viewDirection \x3d normalize(vpos - camPos);\n        ","\n        float ssao \x3d evaluateAmbientOcclusionInverse();\n        ssao *\x3d getBakedOcclusion();\n\n        float additionalAmbientScale \x3d _oldHeuristicLighting(vpos + localOrigin);\n        vec3 additionalLight \x3d ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n        ",
"\n        vec3 matColor \x3d max(ambient, diffuse);\n        ","\n        ","\n        ","\n        gl_FragColor \x3d highlightSlice(vec4(shadedColor, opacity_), vpos);\n      }\n    "])),b.hasColorTexture?d.glsl(h||(h=c(["\n        vec4 texColor \x3d texture2D(tex, vuv0);\n        ","\n        discardOrAdjustAlpha(texColor);"],["\n        vec4 texColor \x3d texture2D(tex, vuv0);\n        ","\n        discardOrAdjustAlpha(texColor);"])),b.textureAlphaPremultiplied?"texColor.rgb /\x3d texColor.a;":
""):d.glsl(k||(k=c(["vec4 texColor \x3d vec4(1.0);"],["vec4 texColor \x3d vec4(1.0);"]))),b.usePBR?"applyPBRFactors();":"",b.receiveShadows?"float shadow \x3d readShadowMap(vpos, linearDepth);":0===b.viewingMode?"float shadow \x3d lightingGlobalFactor * (1.0 - additionalAmbientScale);":"float shadow \x3d 0.0;",b.attributeColor?d.glsl(l||(l=c(["\n        vec3 albedo_ \x3d mixExternalColor(vColor.rgb * matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n        float opacity_ \x3d layerOpacity * mixExternalOpacity(vColor.a * opacity, texColor.a, vcolorExt.a, int(colorMixMode));"],
["\n        vec3 albedo_ \x3d mixExternalColor(vColor.rgb * matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n        float opacity_ \x3d layerOpacity * mixExternalOpacity(vColor.a * opacity, texColor.a, vcolorExt.a, int(colorMixMode));"]))):d.glsl(m||(m=c(["\n        vec3 albedo_ \x3d mixExternalColor(matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n        float opacity_ \x3d layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, int(colorMixMode));\n          ",
""],["\n        vec3 albedo_ \x3d mixExternalColor(matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n        float opacity_ \x3d layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, int(colorMixMode));\n          ",""])),b.usePBR?d.glsl(n||(n=c(["\n          if (int(colorMixMode) \x3d\x3d 3) {\n            reflectance \x3d 0.2;\n            roughness \x3d 0.6;\n            metalness \x3d 0.0;\n          }"],["\n          if (int(colorMixMode) \x3d\x3d 3) {\n            reflectance \x3d 0.2;\n            roughness \x3d 0.6;\n            metalness \x3d 0.0;\n          }"]))):
""),d.glsl(p||(p=c(["\n        vec3 shadedNormal \x3d normalize(vNormalWorld);\n        albedo_ *\x3d 1.2;\n        vec3 viewForward \x3d - vec3(view[0][2], view[1][2], view[2][2]);\n        float alignmentLightView \x3d clamp(dot(-viewForward, lightingMainDirection), 0.0, 1.0);\n        float transmittance \x3d 1.0 - clamp(dot(-viewForward, shadedNormal), 0.0, 1.0);\n        float treeRadialFalloff \x3d vColor.r;\n        float backLightFactor \x3d 0.5 * treeRadialFalloff * alignmentLightView * transmittance * (1.0 - shadow);\n        additionalLight +\x3d backLightFactor * lightingMainIntensity;"],
["\n        vec3 shadedNormal \x3d normalize(vNormalWorld);\n        albedo_ *\x3d 1.2;\n        vec3 viewForward \x3d - vec3(view[0][2], view[1][2], view[2][2]);\n        float alignmentLightView \x3d clamp(dot(-viewForward, lightingMainDirection), 0.0, 1.0);\n        float transmittance \x3d 1.0 - clamp(dot(-viewForward, shadedNormal), 0.0, 1.0);\n        float treeRadialFalloff \x3d vColor.r;\n        float backLightFactor \x3d 0.5 * treeRadialFalloff * alignmentLightView * transmittance * (1.0 - shadow);\n        additionalLight +\x3d backLightFactor * lightingMainIntensity;"]))),
b.usePBR?d.glsl(q||(q=c(["\n            float additionalAmbientIrradiance \x3d additionalAmbientIrradianceFactor * lightingMainIntensity[2];\n            vec3 normalGround \x3d normalize(vpos + localOrigin);\n            vec3 shadedColor \x3d evaluateSceneLightingPBR(shadedNormal, albedo_, shadow, 1.0 - ssao, additionalLight, viewDirection, normalGround, roughness, metalness, emission, reflectance, additionalAmbientIrradiance);"],["\n            float additionalAmbientIrradiance \x3d additionalAmbientIrradianceFactor * lightingMainIntensity[2];\n            vec3 normalGround \x3d normalize(vpos + localOrigin);\n            vec3 shadedColor \x3d evaluateSceneLightingPBR(shadedNormal, albedo_, shadow, 1.0 - ssao, additionalLight, viewDirection, normalGround, roughness, metalness, emission, reflectance, additionalAmbientIrradiance);"]))):
"vec3 shadedColor \x3d evaluateSceneLighting(shadedNormal, albedo_, shadow, 1.0 - ssao, additionalLight);")));a.include(E.DefaultMaterialAuxiliaryPasses,b);return a};var f,h,k,l,n,m,p,q,g});